
## throttle
* 函数节流: 指定时间间隔内只会执行一次任务；
* 运用b包,修改父级函数存储的时间变量
* 结构:
```
function throttle(func, delay = 100){
  // 用来保存计时器和上一次执行的时间
  const preTime = new Date().getTime() 
      return function(){
         const now = new Date().getTime();
        // 函数只会在大于delay时间触发 其他时间的操作都会无效
        if(now > (previous + delay){
          // 如果当前时间大于delay时间则执行函数
        }
      }
}
```
* 场景类比
1 秒内连续播放 24 张以上的图片时，在人眼的视觉中就会形成一个连贯的动画，所以在电影的播放（以前是，现在不知道）中基本是以每秒 24 张的速度播放的，为什么不 100 张或更多是因为 24 张就可以满足人类视觉需求的时候，100 张就会显得很浪费资源。
* 使用方法 传入函数和delay时间生成节流函数 用来绑定事件
* 使用场景 scroll滚动时减少不必要的触发
## debounce
* 函数防抖: 任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。
* 运用b包,修改父级函数存储的时间变量
* 结构:
```
function debounce(fn,delay=1000){
  let timer;
  return function(){
    // 只要函数被调用，清除上一个定时器的执行 关键步骤!
    clearTimeout(timer)
  }
  // 每次调用函数都会新建一个定时器,只要在delay时间内不被调用这个定时器才会执行
  timer = setTimeout(() => {
    fn(args);
  }, delay);
}
```
* 场景类比
假设电梯一次只能载一人的话，10 个人要上楼的话电梯就得走 10 次，是一种浪费资源的行为；而实际生活正显然不是这样的，当电梯里有人准备上楼的时候如果外面又有人按电梯的话，电梯会再次打开直到满载位置，从电梯的角度来说，这时一种节约资源的行为（相对于一次只能载一个人）。
* 使用方法 传入函数和delay时间生成节防抖函数 用来绑定事件
* 使用场景 这里以用户注册时验证用户名是否被占用为例，如今很多网站为了提高用户体验，当用户输入第一个字符后的一段时间内如果还有字符输入的话，那就暂时不去请求判断用户名是否被占用。在这里引入函数防抖就能很好地解决这个问题：

## 参考
[函数节流与函数防抖](https://justclear.github.io/throttle-and-debounce/)